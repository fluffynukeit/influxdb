package tsm1

import (
	"github.com/influxdata/influxdb/tsdb"
)

{{range .}}
// Read{{.Name}}BlockAt returns the {{.name}} values corresponding to the given index entry.
func (t *TSMReader) Read{{.Name}}BlockAt(entry *IndexEntry, vals *[]{{.Name}}Value) ([]{{.Name}}Value, error) {
	t.mu.RLock()
	v, err := t.accessor.read{{.Name}}Block(entry, vals)
	t.mu.RUnlock()
	return v, err
}

// Read{{.Name}}ArrayBlockAt fills vals with the {{.name}} values corresponding to the given index entry.
func (t *TSMReader) Read{{.Name}}ArrayBlockAt(entry *IndexEntry, vals *tsdb.{{.Name}}Array) error {
	t.mu.RLock()
	err := t.accessor.read{{.Name}}ArrayBlock(entry, vals)
	t.mu.RUnlock()
	return err
}
{{end}}

// blockAccessor abstracts a method of accessing blocks from a
// TSM file.
type blockAccessor interface {
	init() (*indirectIndex, error)
	read(key []byte, timestamp int64) ([]Value, error)
	readAll(key []byte) ([]Value, error)
	readBlock(entry *IndexEntry, values []Value) ([]Value, error)
{{- range .}}
	read{{.Name}}Block(entry *IndexEntry, values *[]{{.Name}}Value) ([]{{.Name}}Value, error)
	read{{.Name}}ArrayBlock(entry *IndexEntry, values *tsdb.{{.Name}}Array) error
{{- end}}
	readBytes(entry *IndexEntry, buf []byte) (uint32, []byte, error)
	rename(path string) error
	path() string
	close() error
	free() error
}

{{range .}}
func (m *mmapAccessor) read{{.Name}}Block(entry *IndexEntry, values *[]{{.Name}}Value) (ar []{{.Name}}Value, e error) {
	m.incAccess()
	defer m.decAccess()

	m.mu.RLock()
	defer m.mu.RUnlock()
	b, err := m.b.bytes()
	if err != nil {
		return nil, err
	}
	if m.onDemand {
		defer m.freeErr(&e)
	}
	if int64(len(b)) < entry.Offset+int64(entry.Size) {
		return nil, ErrTSMClosed
	}

	var a []{{.Name}}Value
	a, err = Decode{{.Name}}Block(b[entry.Offset+4:entry.Offset+int64(entry.Size)], values)

	if m.onDemand {
		// Copy to another buffer because we'll unmap m.b soon.
		tmp := make([]{{.Name}}Value, len(a))
		copy(tmp, a)
		a = tmp
	}

	if err != nil {
		return nil, err
	}

	return a, nil
}

func (m *mmapAccessor) read{{.Name}}ArrayBlock(entry *IndexEntry, values *tsdb.{{.Name}}Array) (e error) {
	m.incAccess()
	defer m.decAccess()

	m.mu.RLock()
	defer m.mu.RUnlock()
	b, err := m.b.bytes()
	if err != nil {
		return err
	}
	if m.onDemand {
		defer m.freeErr(&e)
	}
	if int64(len(b)) < entry.Offset+int64(entry.Size) {
		return ErrTSMClosed
	}

	err = Decode{{.Name}}ArrayBlock(b[entry.Offset+4:entry.Offset+int64(entry.Size)], values)

	return err
}
{{end}}
